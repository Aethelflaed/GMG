%{

#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include <iostream>

#include "Parser.h"
#include "Makefile/Generator.hpp"

extern "C"
{
	int yyparse();
    int yylex();

    int yywrap()
    {
        return 1;
    }

	extern char* yytext;

	void yyerror(const char* str)
	{
		std::cerr << "Error : \"" << str << "\"" << std::endl;
		std::cerr << "Scanning : \"" << yytext << "\"" << std::endl;
	}
}

%}

%union
{
	char String[256];
	long long Integer;
	unsigned int Natural;
	int Boolean;
	double Double;
	float Float;
}

%token T_EXIT
%token T_HELP

%token T_LIST

%token T_ADD
%token T_EDIT
%token T_RM
%token T_SET

%token <String>T_BOOL_OPTION
%token <Boolean>T_BOOL_VALUE

%token <String>T_CONFIG_PARAM
%token T_PATH

%token T_TARGET
%token T_CONFIG

%token T_END
%token T_MODULE
%token T_VERSION

%token T_TYPE
%token <Natural>T_TARGET_TYPE

%token <String>T_FILE
%token <String>T_NUMBER
%token <String>T_WORD

%type <Natural>help_command

%type <String>quoted_name
%type <String>quoted_file
%type <Boolean>bool_value

%start configurations

%%

configurations: /* empty */
			  | configurations configuration

configuration: target
			 | config
			 | configuration_help
			 | exit

exit: T_EXIT
   {
		if (Parser::getParser().isInteractive())
		{
			std::cout << "Bye!" << std::endl;
		}

		Parser::getParser().getMakefileGenerator().generate();

		exit(0);
   }

configuration_help: T_HELP help_command
	{
		if (Parser::getParser().isInteractive())
		{
			int command = $2;
#			include "grammar_help_part.h"
		}
	}

help_command: /* empty */	{ $$ = 0;			}
			| T_TARGET		{ $$ = T_TARGET;	}
			| T_CONFIG		{ $$ = T_CONFIG;	}

config: T_CONFIG config_command

config_command: config_bool_param
			  | config_path_param
			  | config_param
			  | config_list

config_bool_param: T_SET T_BOOL_OPTION bool_value
	{
		Makefile::Config& config = Parser::getParser().getCurrentConfig();
		char firstChar = (char) tolower((int) $2[0]);
		if (firstChar == 'd')
		{
			config.setDebug($3 != 0);
		}
		else
		{
			config.setVerbose($3 != 0);
		}
	}

config_path_param: T_ADD T_CONFIG_PARAM T_PATH quoted_file
	{
		Makefile::Config& config = Parser::getParser().getCurrentConfig();
		char firstChar = (char) tolower((int) $2[0]);
		if (firstChar == 'i')
		{
			config.addIncludePath($4);
		}
		else
		{
			config.addLibraryPath($4);
		}
	}

config_param: T_ADD T_CONFIG_PARAM quoted_file
	{
		Parser::getParser().getCurrentConfig().addLibrary($3);
	}

config_list: T_LIST
	{
		if (Parser::getParser().isInteractive())
		{
			std::cout << Parser::getParser().getCurrentConfig() << std::endl;
		}
	}

target:	T_TARGET target_command
	  | target_mode

target_mode: T_END
		   {
				Parser::getParser().setTarget(nullptr);
				Parser::getParser().setState(INITIAL);
		   }
		   | T_LIST
		   {
			if (Parser::getParser().isInteractive())
			{
				std::cout << Parser::getParser().getTarget() << std::endl;
			}
		   }
		   | T_SET target_mode_param
		   | T_MODULE target_mode_modules

target_mode_param: T_VERSION T_NUMBER
				 {
						Parser::getParser().getTarget().setVersion($2);
				 }
				 | T_TYPE T_TARGET_TYPE
				 {
						Parser::getParser().getTarget().setType(Makefile::TargetType($2));
				 }

target_mode_modules: T_ADD quoted_file
				   {
						Parser::getParser().getTarget().addModule($2);
				   }
				   | T_RM quoted_file
				   {
						try
						{
							Parser::getParser().getTarget().removeModule($2);
						}
						catch (const std::out_of_range& ex)
						{
							std::cerr << ex.what() << std::endl;
						}
				   }

/* Target commands : add, edit, remove, list */

target_command: target_add
			  | target_edit
			  | target_rm
			  | target_list

target_add: T_ADD quoted_name
	{
		try
		{
			Parser& parser = Parser::getParser();
			parser.setTarget(&(parser.getMakefileGenerator().addTarget($2)));
			parser.setState(TARGET);
		}
		catch (const std::invalid_argument& ex)
		{
			std::cerr << ex.what() << std::endl;
		}
	}

target_edit: T_EDIT quoted_name
	{
		try
		{
			Parser& parser = Parser::getParser();
			parser.setTarget(&parser.getMakefileGenerator().getTarget($2));
			parser.setState(TARGET);
		}
		catch (const std::out_of_range& ex)
		{
			std::cerr << ex.what() << std::endl;
		}
	}

target_rm: T_RM quoted_name
	{
		try
		{
			Parser::getParser().getMakefileGenerator().removeTarget($2);
		}
		catch (const std::out_of_range& ex)
		{
			std::cerr << ex.what() << std::endl;
		}
	}

target_list: T_LIST
	{
		if (Parser::getParser().isInteractive())
		{
			std::cout << "Targets list :" << std::endl;
			for (auto pair : Parser::getParser().getMakefileGenerator().getTargets())
			{
				std::cout << *(pair.second) << std::endl;
			}
		}
	}

/* Values */

quoted_name: '"' T_WORD '"'
		   {
				strcpy($$, $2);
		   }

quoted_file: '"' T_FILE '"'
		   {
				strcpy($$, $2);
		   }
		   | '"' T_WORD '"'
		   {
				strcpy($$, $2);
		   }

bool_value: T_BOOL_VALUE
		  {
				$$ = $1;
		  }
		  | T_NUMBER
		  {
				$$ = strtol($1, nullptr, 10) != 0;
		  }

%%

