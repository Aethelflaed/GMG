%{

#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include <iostream>

#include "Parser.h"
#include "Makefile/Builder.hpp"

extern "C"
{
	int yyparse();
    int yylex();

    int yywrap()
    {
        return 1;
    }

	extern char* yytext;

	void yyerror(const char* str)
	{
		std::cerr << "Error : \"" << str << "\"" << std::endl;
		std::cerr << "Scanning : \"" << yytext << "\"" << std::endl;
	}
}

%}

%union
{
	char string[100];
	int integer;
	int boolean;
	void* pointer;
	char* charPointer;
}

%token T_EXIT

%token T_LIST

%token T_OPTION
%token T_SET
%token <string>T_BOOL_OPTION
%token <boolean> T_BOOL_VALUE

%token T_TARGET
%token T_ADD
%token T_EDIT
%token T_RM

%token T_END
%token T_MODULE
%token T_VERSION
%token T_SHOW

%token <string>T_FILE
%token <string>T_NUMBER
%token <string>T_WORD

%type <string>quoted_name
%type <string>quoted_file

%start configurations

%%

configurations: /* empty */
			  | configurations configuration

configuration: target
			 | option
			 | exit

exit: T_EXIT
   {
		if (Parser::getParser().isInteractive())
		{
			std::cout << "Bye!" << std::endl;
		}
		exit(0);
   }

option: T_OPTION option_command
	  {
	  }

option_command: T_SET option_set
			  | T_LIST
			{
				std::cout << Parser::getParser()
									.getMakefile()
									.getOptions() << std::endl;
			}

option_set: T_BOOL_OPTION T_BOOL_VALUE
		  {
				if (strcmp($1, "debug") == 0)
				{
					Parser::getParser()
							.getMakefile()
							.getOptions().setDebug($2);
				}
				else if (strcmp($1, "verbose") == 0)
				{
					Parser::getParser()
							.getMakefile()
							.getOptions().setVerbose($2);
				}
		  }
		  | T_BOOL_OPTION T_NUMBER
		  {
				bool value = strtol($2, nullptr, 10) != 0;
				if (strcmp($1, "debug") == 0)
				{
					Parser::getParser()
							.getMakefile()
							.getOptions().setDebug(value);
				}
				else if (strcmp($1, "verbose") == 0)
				{
					Parser::getParser()
							.getMakefile()
							.getOptions().setVerbose(value);
				}
		  }

target:	T_TARGET target_command
	  | target_mode

target_mode: T_END
		   {
				Parser::getParser().setTarget(nullptr);
				Parser::getParser().setState(INITIAL);
		   }
		   | T_SHOW
		   {
				std::cout << Parser::getParser().getTarget() << std::endl;
		   }
		   | target_mode_version
		   | T_MODULE target_mode_modules

target_mode_version: T_SET T_VERSION T_NUMBER
				   {
						Parser::getParser().getTarget().setVersion($3);
				   }

target_mode_modules: T_ADD quoted_file
				   {
						Parser::getParser().getTarget().addModule($2);
				   }
				   | T_RM quoted_file
				   {
						try
						{
							Parser::getParser().getTarget().removeModule($2);
						}
						catch (std::out_of_range ex)
						{
							std::cerr << ex.what() << std::endl;
						}
				   }

target_command: target_add
			  | target_edit
			  | target_rm
			  | target_list

target_add: T_ADD quoted_name
		  {
				try
				{
					Parser& parser = Parser::getParser();
					parser.setTarget(&parser.getMakefile().addTarget($2));
					parser.setState(TARGET);
				}
				catch (std::invalid_argument ex)
				{
					std::cerr << ex.what() << std::endl;
				}
		  }

target_edit: T_EDIT quoted_name
		   {
				try
				{
					Parser& parser = Parser::getParser();
					parser.setTarget(&parser.getMakefile().getTarget($2));
					parser.setState(TARGET);
				}
				catch (std::out_of_range ex)
				{
					std::cerr << ex.what() << std::endl;
				}
		   }

target_rm: T_RM quoted_name
		 {
				try
				{
					Parser::getParser().getMakefile().removeTarget($2);
				}
				catch (std::out_of_range ex)
				{
					std::cerr << ex.what() << std::endl;
				}
		 }

target_list: T_LIST
		   {
				std::cout << "Targets list :" << std::endl;
				for (auto pair : Parser::getParser().getMakefile().getTargets())
				{
					std::cout << " - " << pair.second;
				}
		   }

quoted_name: '"' T_WORD '"'
		   {
				strcpy($$, $2);
		   }

quoted_file: '"' T_FILE '"'
		   {
				strcpy($$, $2);
		   }
		   | '"' T_WORD '"'
		   {
				strcpy($$, $2);
		   }


%%

